"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const file_output_1 = require("./file-output");
class Synexa {
    constructor(options) {
        this.apiKey = options.auth;
        this.client = axios_1.default.create({
            baseURL: options.baseUrl || 'https://api.synexa.ai/v1',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': this.apiKey
            }
        });
    }
    async createPrediction(input) {
        try {
            const response = await this.client.post('/predictions', input);
            return response.data;
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error)) {
                throw new Error(`Failed to create prediction: ${error.message}`);
            }
            throw error;
        }
    }
    async getPrediction(id) {
        try {
            const response = await this.client.get(`/predictions/${id}`);
            return response.data;
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error)) {
                throw new Error(`Failed to get prediction: ${error.message}`);
            }
            throw error;
        }
    }
    async waitWithPolling(prediction, options = {}, signal, progress) {
        const interval = options.interval || 500;
        let currentPrediction = prediction;
        while (currentPrediction.status !== 'succeeded' && currentPrediction.status !== 'failed') {
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new Error('Prediction cancelled');
            }
            await new Promise(resolve => setTimeout(resolve, interval));
            currentPrediction = await this.getPrediction(currentPrediction.id);
            if (progress) {
                progress(currentPrediction);
            }
        }
        if (currentPrediction.status === 'failed') {
            throw new Error(`Prediction failed: ${currentPrediction.error}`);
        }
        return currentPrediction;
    }
    async waitWithBlock(prediction, options = {}, signal, progress) {
        try {
            const response = await this.client.post(`/predictions/${prediction.id}/wait`, {
                timeout: options.timeout || 60
            }, {
                signal
            });
            const result = response.data;
            if (progress) {
                progress(result);
            }
            if (result.status === 'failed') {
                throw new Error(`Prediction failed: ${result.error}`);
            }
            return result;
        }
        catch (error) {
            if (error instanceof Error && error.name === 'AbortError') {
                throw new Error('Prediction cancelled');
            }
            // If blocking wait fails, fall back to polling
            return this.waitWithPolling(prediction, options, signal, progress);
        }
    }
    async wait(prediction, options = {}, signal, progress) {
        const waitType = options.type || 'block';
        if (progress) {
            progress(prediction);
        }
        if (waitType === 'block') {
            return this.waitWithBlock(prediction, options, signal, progress);
        }
        else {
            return this.waitWithPolling(prediction, options, signal, progress);
        }
    }
    async run(identifier, options) {
        const [owner, model] = identifier.split('/');
        const [name, version] = model.split(':');
        const prediction = await this.createPrediction({
            model: `${owner}/${name}`,
            input: options.input,
            webhook: options.webhook,
            webhook_events_filter: options.webhook_events_filter
        });
        const result = await this.wait(prediction, options.wait, options.signal, options.progress);
        if (!result.output) {
            throw new Error('No output received from the prediction');
        }
        return result.output.map(output => {
            if (output.startsWith('http')) {
                return new file_output_1.FileOutput(output);
            }
            return output;
        });
    }
}
exports.default = Synexa;
